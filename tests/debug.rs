//! Tests for any Debug implementations.
//!
//! Why test something as mundane as a trait that can be *autogenerated*? Why
//! not just rely on that, then not have to worry about updating these tests
//! when that changes?
//!
//! Usually I’d agree with you, but I’m doing it anyway for two reasons:
//!
//! 1. A lot of structs’ names are re-used, most infamously `local::DateTime`,
//!    `offset::DateTime` and `zoned::DateTime`. It’s important to make sure
//!    that the Debug name for each struct is unique so the user can know
//!    which type a value actually has.
//!
//! 2. We need to make sure all the data shown in a Debug string is also
//!    accessible by a calling method on the value, rather than *only* by
//!    using Debug. To do this, we need to check that Debug strings aren’t
//!    suddenly changed to include an extra hidden field.
//!
//! So everything below is testing a hand-written Debug implementation, rather
//! than the derived one.

extern crate datetime;
use datetime::*;
use std::fmt::Debug;


fn debug<T: Debug>(t: T) -> String {
    format!("{:?}", t)
}


#[test]
fn instant() {
    let instant = Instant::at_ms(1048, 576);
    assert_eq!(debug(instant), "Instant(1048s/576ms)");
}

#[test]
fn year() {
    let year = datetime::Year::from(2016);
    assert_eq!(debug(year), "Year(2016)");
}

#[test]
fn recently() {
    let date = local::Date::ymd(1600, Month::February, 28).unwrap();
    assert_eq!(debug(date), "local::Date(1600-02-28)");
}

#[test]
fn just_then() {
    let date = local::Date::ymd(-753, Month::December, 1).unwrap();
    assert_eq!(debug(date), "local::Date(-0753-12-01)");
}

#[test]
fn far_far_future() {
    let date = local::Date::ymd(10601, Month::January, 31).unwrap();
    assert_eq!(debug(date), "local::Date(+10601-01-31)");
}

#[test]
fn midday() {
    let time = local::Time::hms(12, 0, 0).unwrap();
    assert_eq!(debug(time), "local::Time(12:00:00.000)");
}

#[test]
fn ascending() {
    let then = local::DateTime::new(
                local::Date::ymd(2009, Month::February, 13).unwrap(),
                local::Time::hms(23, 31, 30).unwrap());

    assert_eq!(debug(then), "local::DateTime(2009-02-13T23:31:30.000)");
}

#[test]
fn zulu() {
    let offset = offset::Offset::utc();
    assert_eq!(debug(offset), "offset::Offset(Z)");
}

#[test]
fn offset() {
    let offset = offset::Offset::of_seconds(-25 * 60 - 21).unwrap();
    assert_eq!(debug(offset), "offset::Offset(-00:25:21)");
}

#[test]
fn offset_date_time() {
    let offset = offset::Offset::of_seconds(25 * 60 + 21).unwrap();

    let then = local::DateTime::new(
                local::Date::ymd(2009, Month::February, 13).unwrap(),
                local::Time::hms(23, 31, 30).unwrap());

    let debugged = debug(offset.transform_date(then));
    assert_eq!(debugged, "offset::DateTime(2009-02-13T23:31:30.000+00:25:21)");
}
